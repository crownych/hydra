/*
 * Copyright Â© 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */

package cli

import (
	"bufio"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"

	hydra "github.com/ory/hydra/corp104/sdk/go/corp104/swagger"
	"github.com/ory/hydra/pkg"
)

const (
	CookieFileFormat = "%s\t%s\t%s\t%s\t%d\t%s\t%s"
)

func checkResponse(response *hydra.APIResponse, err error, expectedStatusCode int) {
	if response != nil {
		var method string
		if response.Response != nil && response.Response.Request != nil {
			method = response.Request.Method
		}
		pkg.Must(err, "Command failed because calling \"%s %s\" resulted in error \"%s\" occurred.\n%s\n", method, response.RequestURL, err, response.Payload)
	} else {
		pkg.Must(err, "Command failed because error \"%s\" occurred and no response is available.\n", err)
	}

	if response.StatusCode != expectedStatusCode {
		fmt.Fprintf(os.Stderr, "Command failed because calling \"%s %s\" resulted in status code \"%d\" but code \"%d\" was expected.\n%s\n", response.Request.Method, response.RequestURL, response.StatusCode, expectedStatusCode, response.Payload)
		os.Exit(1)
		return
	}
}

func formatResponse(response interface{}) string {
	out, err := json.MarshalIndent(response, "", "\t")
	pkg.Must(err, `Command failed because an error ("%s") occurred while prettifying output.`, err)
	return string(out)
}

func getEndpointHostname(endpointURL string) string {
	u, err := url.Parse(endpointURL)
	if err != nil {
		panic(err)
	}
	return u.Hostname()
}

func convertToSwaggerJsonWebKeySet(jwksJSON []byte) *hydra.JsonWebKeySet {
	var jwks hydra.JsonWebKeySet
	err := json.Unmarshal(jwksJSON, &jwks)
	if err != nil {
		panic("Invalid jwks:" + err.Error())
	}
	return &jwks
}

func convertToSwaggerJsonWebKey(signingJwkJSON []byte) *hydra.JsonWebKey {
	var signingJwk *hydra.JsonWebKey
	err := json.Unmarshal(signingJwkJSON, &signingJwk)
	if err != nil {
		panic("Invalid signing jwk:" + err.Error())
	}
	return signingJwk
}

func storeCookies(filename string, cookies []*http.Cookie, host string) {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	f.WriteString("# DO NOT EDIT THIS FILE \n")
	f.WriteString("# Hydra HTTP Cookie File \n\n")

	for idx, cookie := range cookies {
		domain := cookie.Domain
		if domain == "" {
			domain = host
		}
		subDomains := "TRUE"
		if domain == "" {
			subDomains = "FALSE"
		}
		path := cookie.Path
		secure := strings.ToUpper(strconv.FormatBool(cookie.Secure))
		var expiresAt int64
		if cookie.Expires.IsZero() {
			expiresAt = time.Now().Add(8 * time.Hour).Unix()
		} else {
			expiresAt = cookie.Expires.Unix()
		}
		name := cookie.Name
		value := cookie.Value
		content := fmt.Sprintf(CookieFileFormat, domain, subDomains, path, secure, expiresAt, name, value)
		if idx > 0 {
			content = "\n" + content
		}
		if _, err = f.WriteString(content); err != nil {
			panic(err)
		}
	}
}

func getStoredCookies(filename string) []*http.Cookie {
	f, err := os.Open(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	var cookies []*http.Cookie
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if line != "" && !strings.HasPrefix(line, "#") {
			info := strings.Split(line, "\t")
			cookie := &http.Cookie{
				Domain: info[0],
				Path: info[2],
				Name: info[5],
				Value: info[6],
			}
			if info[3] == "TRUE" {
				cookie.Secure = true
			}
			if info[4] != "0" {
				cookie.Expires = parseUnixTimestamp(info[4])
				if cookie.Expires.Before(time.Now()) {
					panic("Cookie has expired")
				}
			}
			cookies = append(cookies, cookie)
		}
	}
	if err := scanner.Err(); err != nil {
		panic(err)
	}
	return cookies
}

func parseUnixTimestamp(unixTimestamp string) time.Time {
	i, err := strconv.ParseInt(unixTimestamp, 10, 64)
	if err != nil {
		panic(err)
	}
	return time.Unix(i, 0)
}