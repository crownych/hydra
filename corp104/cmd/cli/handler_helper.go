/*
 * Copyright Â© 2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author		Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @copyright 	2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>
 * @license 	Apache-2.0
 */

package cli

import (
	"bufio"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/go-playground/validator"
	"github.com/spf13/cobra"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"

	hydra "github.com/ory/hydra/corp104/sdk/go/corp104/swagger"
	"github.com/ory/hydra/pkg"
)

const (
	CookieFileFormat = "%s\t%s\t%s\t%s\t%d\t%s\t%s"
)

func checkResponse(response *hydra.APIResponse, err error, expectedStatusCode int) {
	if response != nil {
		var method string
		if response.Response != nil && response.Response.Request != nil {
			method = response.Request.Method
		}
		pkg.Must(err, "Command failed because calling \"%s %s\" resulted in error \"%s\" occurred.\n%s\n", method, response.RequestURL, err, response.Payload)
	} else {
		pkg.Must(err, "Command failed because error \"%s\" occurred and no response is available.\n", err)
	}

	if response.StatusCode != expectedStatusCode {
		fmt.Fprintf(os.Stderr, "Command failed because calling \"%s %s\" resulted in status code \"%d\" but code \"%d\" was expected.\n%s\n", response.Request.Method, response.RequestURL, response.StatusCode, expectedStatusCode, response.Payload)
		os.Exit(1)
		return
	}
}

func formatResponse(response interface{}) string {
	out, err := json.MarshalIndent(response, "", "\t")
	pkg.Must(err, `Command failed because an error ("%s") occurred while prettifying output.`, err)
	return string(out)
}

func getEndpointHostname(endpointURL string) string {
	u, err := url.Parse(endpointURL)
	if err != nil {
		panic(err)
	}
	return u.Hostname()
}

func storeCookies(filename string, cookies []*http.Cookie, host string) {
	f, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	defer f.Close()

	f.WriteString("# DO NOT EDIT THIS FILE \n")
	f.WriteString("# Hydra HTTP Cookie File \n\n")

	for idx, cookie := range cookies {
		domain := cookie.Domain
		if domain == "" {
			domain = host
		}
		subDomains := "TRUE"
		if domain == "" {
			subDomains = "FALSE"
		}
		path := cookie.Path
		secure := strings.ToUpper(strconv.FormatBool(cookie.Secure))
		var expiresAt int64
		if cookie.Expires.IsZero() {
			expiresAt = time.Now().Add(8 * time.Hour).Unix()
		} else {
			expiresAt = cookie.Expires.Unix()
		}
		name := cookie.Name
		value := cookie.Value
		content := fmt.Sprintf(CookieFileFormat, domain, subDomains, path, secure, expiresAt, name, value)
		if idx > 0 {
			content = "\n" + content
		}
		if _, err = f.WriteString(content); err != nil {
			panic(err)
		}
	}
}

func getStoredCookies(filename string) map[string]string {
	f, err := os.Open(filename)
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	defer f.Close()

	cookies := make(map[string]string)
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if line != "" && !strings.HasPrefix(line, "#") {
			info := strings.Split(line, "\t")
			cookie := &http.Cookie{
				Domain: info[0],
				Path:   info[2],
				Name:   info[5],
				Value:  info[6],
			}
			if info[3] == "TRUE" {
				cookie.Secure = true
			}
			if info[4] != "0" {
				cookie.Expires = parseUnixTimestamp(info[4])
				if cookie.Expires.Before(time.Now()) {
					panic("Cookie has expired")
				}
			}
			cookies[cookie.Name] = cookie.Value
		}
	}
	if err := scanner.Err(); err != nil {
		panic(err)
	}
	return cookies
}

func deleteCookies(filename string) {
	os.Remove(filename)
}

func parseInt64(s string) (*int64, error) {
	i, err := strconv.ParseInt(s, 10, 64)
	if err != nil {
		return nil, err
	}
	return &i, nil
}

func mustParseInt64(s string) int64 {
	i, err := parseInt64(s)
	if err != nil {
		panic(err)
	}
	return *i
}

func parseUnixTimestamp(unixTimestamp string) time.Time {
	return time.Unix(mustParseInt64(unixTimestamp), 0)
}

func getAuthServicePublicJWK(cmd *cobra.Command) *hydra.JsonWebKey {
	authSrvPubKeyJSON, _ := cmd.Flags().GetString("auth-public-jwk")
	jwk, err := hydra.LoadJsonWebKey([]byte(authSrvPubKeyJSON))
	if err != nil {
		pkg.Must(err, "Error: unable to fetch public key of authorization service - " + err.Error())
	}
	return jwk
}

func getJWKSFromCmd(cmd *cobra.Command) *hydra.JsonWebKeySet {
	jwksJSON, _ := cmd.Flags().GetString("jwks")
	jwks, err := hydra.LoadJsonWebKeySet([]byte(jwksJSON))
	if err != nil {
		pkg.Must(err, "Error: invalid jwks - " + err.Error())
	}
	err = validator.New().Struct(jwks)
	if err != nil {
		pkg.Must(err, "Error: invalid jwks - " + err.Error())
	}
	return jwks
}

func getSigningJWKFromCmd(cmd *cobra.Command) *hydra.JsonWebKey {
	signingJwkJSON, _ := cmd.Flags().GetString("signing-jwk")
	if signingJwkJSON != "" {
		jwk, err := hydra.LoadJsonWebKey([]byte(signingJwkJSON))
		if err != nil {
			pkg.Must(err, "Error: invalid signing-jwk - " + err.Error())
		}
		return jwk
	}
	// generate new signing key
	cPrivKey, _ := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
	return &hydra.JsonWebKey{
		Alg: "ES256",
		Crv: "P-256",
		Use: "sig",
		Kty: "EC",
		X:   base64.RawURLEncoding.EncodeToString(cPrivKey.X.Bytes()),
		Y:   base64.RawURLEncoding.EncodeToString(cPrivKey.Y.Bytes()),
		D:   base64.RawURLEncoding.EncodeToString(cPrivKey.D.Bytes()),
	}
}

func hydraJsonWebKeyFromPkgJSONWebKey(key pkg.JSONWebKey) hydra.JsonWebKey {
	buf, err := key.MarshalJSON()
	pkg.Must(err, "Error: unable to convert key to JSON Web Key because %s", err)
	var hydraJwk hydra.JsonWebKey
	err = json.Unmarshal(buf, &hydraJwk)
	pkg.Must(err, "Error: unable to convert key to JSON Web Key because %s", err)
	return hydraJwk
}
