/*
 * ORY Hydra - Cloud Native OAuth 2.0 and OpenID Connect Server
 *
 * Welcome to the ORY Hydra HTTP API documentation. You will find documentation for all HTTP APIs here. Keep in mind that this document reflects the latest branch, always. Support for versioned documentation is coming in the future.
 *
 * OpenAPI spec version: Latest
 * Contact: hi@ory.am
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

package swagger

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"
)

type JsonWebKeyApi struct {
	Configuration *Configuration
}

func NewJsonWebKeyApi() *JsonWebKeyApi {
	configuration := NewConfiguration()
	return &JsonWebKeyApi{
		Configuration: configuration,
	}
}

func NewJsonWebKeyApiWithBasePath(basePath string) *JsonWebKeyApi {
	configuration := NewConfiguration()
	configuration.BasePath = basePath

	return &JsonWebKeyApi{
		Configuration: configuration,
	}
}

/**
 * Delete a JSON Web Key
 * Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 *
 * @param kid The kid of the desired key
 * @param set The set
 * @return void
 */
func (a JsonWebKeyApi) DeleteJsonWebKey(kid string, set string) (*APIResponse, error) {

	var localVarHttpMethod = strings.ToUpper("Delete")
	// create path and map variables
	localVarPath := a.Configuration.BasePath + "/keys/{set}/{kid}"
	localVarPath = strings.Replace(localVarPath, "{"+"kid"+"}", fmt.Sprintf("%v", kid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set"+"}", fmt.Sprintf("%v", set), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)
	var localVarPostBody interface{}
	var localVarFileName string
	var localVarFileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		localVarHeaderParams[key] = a.Configuration.DefaultHeader[key]
	}

	// set Authorization header
	authzHeader, err := a.checkADCredentials()
	if err != nil {
		return nil, err
	}
	localVarHeaderParams["Authorization"] = authzHeader

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHttpResponse, err := a.Configuration.APIClient.CallAPI(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)

	var localVarURL, _ = url.Parse(localVarPath)
	localVarURL.RawQuery = localVarQueryParams.Encode()
	var localVarAPIResponse = &APIResponse{Operation: "DeleteJsonWebKey", Method: localVarHttpMethod, RequestURL: localVarURL.String()}
	if localVarHttpResponse != nil {
		localVarAPIResponse.Response = localVarHttpResponse.RawResponse
		localVarAPIResponse.Payload = localVarHttpResponse.Body()
	}

	if err != nil {
		return localVarAPIResponse, err
	}
	return localVarAPIResponse, err
}

/**
 * Delete a JSON Web Key Set
 * Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 *
 * @param set The set
 * @return void
 */
func (a JsonWebKeyApi) DeleteJsonWebKeySet(set string) (*APIResponse, error) {

	var localVarHttpMethod = strings.ToUpper("Delete")
	// create path and map variables
	localVarPath := a.Configuration.BasePath + "/keys/{set}"
	localVarPath = strings.Replace(localVarPath, "{"+"set"+"}", fmt.Sprintf("%v", set), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)
	var localVarPostBody interface{}
	var localVarFileName string
	var localVarFileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		localVarHeaderParams[key] = a.Configuration.DefaultHeader[key]
	}

	// set Authorization header
	authzHeader, err := a.checkADCredentials()
	if err != nil {
		return nil, err
	}
	localVarHeaderParams["Authorization"] = authzHeader

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHttpResponse, err := a.Configuration.APIClient.CallAPI(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)

	var localVarURL, _ = url.Parse(localVarPath)
	localVarURL.RawQuery = localVarQueryParams.Encode()
	var localVarAPIResponse = &APIResponse{Operation: "DeleteJsonWebKeySet", Method: localVarHttpMethod, RequestURL: localVarURL.String()}
	if localVarHttpResponse != nil {
		localVarAPIResponse.Response = localVarHttpResponse.RawResponse
		localVarAPIResponse.Payload = localVarHttpResponse.Body()
	}

	if err != nil {
		return localVarAPIResponse, err
	}
	return localVarAPIResponse, err
}

/**
 * Retrieve a JSON Web Key
 * This endpoint can be used to retrieve JWKs stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 *
 * @param kid The kid of the desired key
 * @param set The set
 * @return *JsonWebKeySet
 */
func (a JsonWebKeyApi) GetJsonWebKey(kid string, set string) (*JsonWebKeySet, *APIResponse, error) {

	var localVarHttpMethod = strings.ToUpper("Get")
	// create path and map variables
	localVarPath := a.Configuration.BasePath + "/keys/{set}/{kid}"
	localVarPath = strings.Replace(localVarPath, "{"+"kid"+"}", fmt.Sprintf("%v", kid), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"set"+"}", fmt.Sprintf("%v", set), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)
	var localVarPostBody interface{}
	var localVarFileName string
	var localVarFileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		localVarHeaderParams[key] = a.Configuration.DefaultHeader[key]
	}

	// set Authorization header
	authzHeader, err := a.checkADCredentials()
	if err != nil {
		return nil, nil, err
	}
	localVarHeaderParams["Authorization"] = authzHeader

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JsonWebKeySet)
	localVarHttpResponse, err := a.Configuration.APIClient.CallAPI(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)

	var localVarURL, _ = url.Parse(localVarPath)
	localVarURL.RawQuery = localVarQueryParams.Encode()
	var localVarAPIResponse = &APIResponse{Operation: "GetJsonWebKey", Method: localVarHttpMethod, RequestURL: localVarURL.String()}
	if localVarHttpResponse != nil {
		localVarAPIResponse.Response = localVarHttpResponse.RawResponse
		localVarAPIResponse.Payload = localVarHttpResponse.Body()
	}

	if err != nil {
		return successPayload, localVarAPIResponse, err
	}
	err = json.Unmarshal(localVarHttpResponse.Body(), &successPayload)
	return successPayload, localVarAPIResponse, err
}

/**
 * Retrieve a JSON Web Key Set
 * This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
 *
 * @param set The set
 * @return *JsonWebKeySet
 */
func (a JsonWebKeyApi) GetJsonWebKeySet(set string) (*JsonWebKeySet, *APIResponse, error) {

	var localVarHttpMethod = strings.ToUpper("Get")
	// create path and map variables
	localVarPath := a.Configuration.BasePath + "/keys/{set}"
	localVarPath = strings.Replace(localVarPath, "{"+"set"+"}", fmt.Sprintf("%v", set), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)
	var localVarPostBody interface{}
	var localVarFileName string
	var localVarFileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		localVarHeaderParams[key] = a.Configuration.DefaultHeader[key]
	}

	// set Authorization header
	authzHeader, err := a.checkADCredentials()
	if err != nil {
		return nil, nil, err
	}
	localVarHeaderParams["Authorization"] = authzHeader

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(JsonWebKeySet)
	localVarHttpResponse, err := a.Configuration.APIClient.CallAPI(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)

	var localVarURL, _ = url.Parse(localVarPath)
	localVarURL.RawQuery = localVarQueryParams.Encode()
	var localVarAPIResponse = &APIResponse{Operation: "GetJsonWebKeySet", Method: localVarHttpMethod, RequestURL: localVarURL.String()}
	if localVarHttpResponse != nil {
		localVarAPIResponse.Response = localVarHttpResponse.RawResponse
		localVarAPIResponse.Payload = localVarHttpResponse.Body()
	}

	if err != nil {
		return successPayload, localVarAPIResponse, err
	}
	err = json.Unmarshal(localVarHttpResponse.Body(), &successPayload)
	return successPayload, localVarAPIResponse, err
}

/**
 * Create or update an JSON Web Key Set
 *
 * @param set
 * @param body
 * @return *PutResourceResponse
 */
func (a JsonWebKeyApi) PutJsonWebKeySet(set string, body JsonWebKeySet) (*PutKeysResponse, *APIResponse, error) {
	if a.Configuration.AuthSvcOfflinePublicJWK == nil {
		return nil, nil, errors.New("'Configuration.AuthSvcOfflinePublicJWK' must be set")
	}

	var localVarHttpMethod = http.MethodPut
	// create path and map variables
	localVarPath := a.Configuration.BasePath + "/keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)
	var localVarPostBody interface{}
	var localVarFileName string
	var localVarFileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		localVarHeaderParams[key] = a.Configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}

	// set Cookie header
	localVarHttpHeaderCookies := make(map[string]string)

	localVarHttpHeaderCookie := a.Configuration.APIClient.SelectHeaderCookie(localVarHttpHeaderCookies)
	if localVarHttpHeaderCookie != "" {
		localVarHeaderParams["Cookie"] = localVarHttpHeaderCookie
	}

	statement, err := a.createKeysStatement(set, body)
	if err != nil {
		return nil, nil, err
	}

	// Create resource_statement payload
	payload := make(map[string]interface{})
	payload["keys_statement"] = statement

	// body params
	localVarPostBody = &payload
	var successPayload = new(PutKeysResponse)
	localVarHttpResponse, err := a.Configuration.APIClient.CallAPI(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)

	var localVarURL, _ = url.Parse(localVarPath)
	localVarURL.RawQuery = localVarQueryParams.Encode()
	var localVarAPIResponse = &APIResponse{Operation: "PutJsonWebKeySet", Method: localVarHttpMethod, RequestURL: localVarURL.String()}
	if localVarHttpResponse != nil {
		localVarAPIResponse.Response = localVarHttpResponse.RawResponse
		localVarAPIResponse.Payload = localVarHttpResponse.Body()
	}

	if err != nil {
		return successPayload, localVarAPIResponse, err
	}
	err = json.Unmarshal(localVarHttpResponse.Body(), &successPayload)
	return successPayload, localVarAPIResponse, err
}

func (a JsonWebKeyApi) createKeysStatement(set string, body JsonWebKeySet) (string, error) {
	if a.Configuration.AuthSvcOfflinePublicJWK == nil {
		return "", errors.New("'Configuration.AuthSvcOfflinePublicJWK' must be set")
	}
	serverPubJwk, serverPubKey, err := convertToJwxJWK(a.Configuration.AuthSvcOfflinePublicJWK)
	if err != nil {
		return "", err
	}

	// client's keys
	signingJwk := a.Configuration.PrivateJWK
	if signingJwk == nil {
		return "", errors.New("signing key is required")
	}
	pubJwk, _, err := convertToJwxJWK(extractPublicJWK(signingJwk))
	if err != nil {
		return "", err
	}
	_, signingKey, err := convertToJwxJWK(signingJwk)
	if err != nil {
		return "", err
	}

	if a.Configuration.ADUsername == "" || a.Configuration.ADPassword == "" {
		return "", errors.New("AD user credentials required")
	}

	// create and sign JWS of client's software statement
	jwsHeaders := make(map[string]interface{})
	jwsHeaders["alg"] = pubJwk.Algorithm()
	jwsHeaders["typ"] = "keys-metadata+jwt"
	jwsHeaders["jwk"] = pubJwk
	bodyMap := map[string]interface{}{
		"aud": a.Configuration.BasePath,
		"iat": time.Now().UTC().Unix(),
		"authentication": map[string]string{
			"ad_user": a.Configuration.ADUsername,
			"ad_pwd": a.Configuration.ADPassword,
		},
		"keys_metadata": map[string]interface{}{
			"set": set,
			"jwks": body,
		},
	}

	payload, err := json.Marshal(&bodyMap)
	if err != nil {
		return "", err
	}
	jwsMsg, err := jwsSign(jwsHeaders, payload, signingKey)
	if err != nil {
		return "", err
	}

	// create JWE using server's public key
	jweMsg, err := jweEncrypt(jwsMsg, serverPubKey, serverPubJwk.KeyID())
	if err != nil {
		return "", err
	}
	return string(jweMsg), nil
}

/**
 * Commit an JSON Web Key Set
 *
 * @param cookies session cookies
 * @param commitCode string
 * @return *CommitResourceResponse
 */
func (a JsonWebKeyApi) CommitJsonWebKeySet(cookies map[string]string, commitCode string) (*CommitKeysResponse, *APIResponse, error) {
	if cookies == nil || len(cookies) == 0 {
		return nil, nil, errors.New("empty session cookies")
	}

	var localVarHttpMethod = http.MethodPut
	// create path and map variables
	localVarPath := a.Configuration.BasePath + "/keys/commit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := make(map[string]string)
	var localVarPostBody interface{}
	var localVarFileName string
	var localVarFileBytes []byte
	// add default headers if any
	for key := range a.Configuration.DefaultHeader {
		localVarHeaderParams[key] = a.Configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := a.Configuration.APIClient.SelectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"application/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.Configuration.APIClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}

	// set Cookie header
	localVarHttpHeaderCookies := make(map[string]string)
	for cookieName, cookieValue := range cookies {
		localVarHttpHeaderCookies[cookieName] = cookieValue
	}

	localVarHttpHeaderCookie := a.Configuration.APIClient.SelectHeaderCookie(localVarHttpHeaderCookies)
	if localVarHttpHeaderCookie != "" {
		localVarHeaderParams["Cookie"] = localVarHttpHeaderCookie
	}

	// body params
	payload := map[string]string{"commit_code": commitCode}

	localVarPostBody = &payload
	var successPayload = new(CommitKeysResponse)
	localVarHttpResponse, err := a.Configuration.APIClient.CallAPI(localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)

	var localVarURL, _ = url.Parse(localVarPath)
	localVarURL.RawQuery = localVarQueryParams.Encode()
	var localVarAPIResponse = &APIResponse{Operation: "CommitJsonWebKeySet", Method: localVarHttpMethod, RequestURL: localVarURL.String()}
	if localVarHttpResponse != nil {
		localVarAPIResponse.Response = localVarHttpResponse.RawResponse
		localVarAPIResponse.Payload = localVarHttpResponse.Body()
	}

	if err != nil {
		return successPayload, localVarAPIResponse, err
	}
	err = json.Unmarshal(localVarHttpResponse.Body(), &successPayload)

	return successPayload, localVarAPIResponse, err
}

func (a JsonWebKeyApi) checkADCredentials() (string, error) {
	user := a.Configuration.ADUsername
	pwd := a.Configuration.ADPassword
	if user == "" || pwd == "" {
		return "", errors.New("AD user credentials required")
	}
	return "Basic " + getBasicAuthEncodedString(user, pwd), nil
}